#!/usr/bin/env bash
# Safe mode
set -Eeuo pipefail
IFS=$'\n\t'

# Error trap
err() { printf "\033[31m✗ %s\033[0m\n" "$*" >&2; }
ok()  { printf "\033[32m✓ %s\033[0m\n" "$*"; }
warn(){ printf "\033[33m⚠ %s\033[0m\n" "$*"; }
trap 'err "Failed at ${FUNCNAME[0]:-main} line $LINENO: $BASH_COMMAND"' ERR

# Optional tracing
[[ -n "${DEBUG:-}" ]] && set -x

# Dry-run support
DRY_RUN="${DRY_RUN:-0}"
declare -a DRY_ACTIONS=()
if [[ "${1:-}" == "--dry-run" ]]; then
  DRY_RUN=1
  shift
fi

run() {
  if [[ "${DRY_RUN}" == "1" ]]; then
    printf "DRY-RUN: "
    printf "%q " "$@"
    printf "\n"
    # record a shell-escaped form
    local q=""; for a in "$@"; do printf -v q "%s%q " "$q" "$a"; done
    DRY_ACTIONS+=("${q% }")
  else
    printf "+ "; printf "%q " "$@"; printf "\n"
    "$@"
  fi
}

usage() {
  cat <<'USAGE'
mrk1 bootstrap

Usage:
  bootstrap bootstrap   # full flow
  bootstrap brew        # brew bundle only
  bootstrap dotfiles    # link dotfiles from dotfiles/
  bootstrap tools       # link executable scripts into ~/.local/bin
  bootstrap defaults    # apply macOS defaults (Darwin only)
  bootstrap doctor      # run doctor if present (non-fatal if missing)
  bootstrap help        # show this help
USAGE
}

# Paths
REPO_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
ASSETS_DIR="${REPO_DIR}/assets"
DOTFILES_DIR="${REPO_DIR}/dotfiles"
SCRIPTS_DIR="${REPO_DIR}/scripts"
DEST_DIR="${HOME}/.local/bin"

ensure_dirs() {
  run mkdir -p "${DEST_DIR}"
}

run_brew_bundle() {
  local ran=0
  shopt -s nullglob
  for bf in "${ASSETS_DIR}/Brewfile" "${REPO_DIR}/Brewfile"; do
    if [[ -f "$bf" ]]; then
      ok "Using Brewfile: $bf"
      if [[ "${DRY_RUN}" == "1" ]]; then
        run brew bundle --file "$bf"
      else
        local log; log="$(mktemp -t mrk1-brew.XXXXXX)"
        # Capture stdout+stderr so we can search for common failure patterns
        if brew bundle --file "$bf" > >(tee -a "$log") 2>&1; then
          :
        else
          warn "brew bundle exited with non-zero status (continuing)"
        fi

        # Parse for SHA-256 mismatch blocks and 404s and print guidance
        if grep -q 'SHA-256 mismatch' "$log"; then
          # Try to extract the last 'Installing <cask>' line to name the cask
          local cask="the-cask"
          local install_line
          install_line="$(grep -E '^(Installing|==> Installing) ' "$log" | tail -n1)"
          if [[ -n "$install_line" ]]; then
            cask="${install_line##* }"
          fi

          local cache_path
          cache_path="$(grep -E 'File:\s*/.*/Library/Caches/Homebrew/downloads/.*' "$log" | awk -F'File: ' '{print $2}' | tail -n1)"
          local BOLD="\033[1m" YELLOW="\033[33m" DIM="\033[2m" RESET="\033[0m"
          printf "%b%b\n" "$BOLD$YELLOW" "Brew reported a SHA-256 mismatch (continuing)."
          printf "%b%s\n" "$DIM" "This usually means the vendor replaced the DMG or the local cache is stale."
          printf "%s\n" "To fix:"
          if [[ -n "$cache_path" ]]; then
            printf "  rm -f %q\n" "$cache_path"
          else
            printf "  rm -f \"\$HOME/Library/Caches/Homebrew/downloads/<filename>.dmg\"\n"
          fi
          printf "  brew fetch --cask %s --force --retry\n" "$cask"
          printf "  brew install --cask %s\n" "$cask"
          printf "%b\n" "$RESET"
        fi

        if grep -q 'curl: (22) The requested URL returned error: 404' "$log"; then
          local BOLD="\033[1m" YELLOW="\033[33m" DIM="\033[2m" RESET="\033[0m"
          printf "%b%b\n" "$BOLD$YELLOW" "Brew encountered a 404 while fetching a cask (continuing)."
          printf "%b%s\n" "$DIM" "This can happen when upstream renames an artifact or a release is moved."
          printf "%s\n" "Try:"
          printf "  brew update\n"
          printf "  brew update-reset\n"
          printf "  brew fetch --cask <caskname> --force --retry\n"
          printf "  brew install --cask <caskname>\n"
          printf "%b\n" "$RESET"
        fi

        rm -f "$log"
      fi
      ran=1
      break
    fi
  done
  shopt -u nullglob
  if [[ $ran -eq 0 ]]; then
    err "No Brewfile found in assets/ or repo root"
    return 1
  fi
}


link_dotfiles() {
  if [[ ! -d "${DOTFILES_DIR}" ]]; then
    warn "dotfiles/ missing; skipping"
    return 0
  fi
  # iterate top-level files only
  while IFS= read -r -d '' src; do
    local base dest
    base="$(basename "$src")"
    case "$base" in
      .*) dest="${HOME}/${base}" ;;  # already has a leading dot
      *)  dest="${HOME}/.${base}" ;;
    esac
    if [[ -L "$dest" || -e "$dest" ]]; then
      local target
      target="$(readlink "$dest" 2>/dev/null || true)"
      if [[ "$target" == "$src" ]]; then
        ok "symlink exists: $dest"
      else
        run mv "$dest" "${dest}.bak.$(date +%s)"
        run ln -s "$src" "$dest"
        ok "linked: $dest -> $src"
      fi
    else
      run ln -s "$src" "$dest"
      ok "linked: $dest -> $src"
    fi
  done < <(find "${DOTFILES_DIR}" -maxdepth 1 -type f -print0)
}

link_tools() {
  ensure_dirs
  # link any shebang-bearing scripts except doctor/bootstrap
  while IFS= read -r -d '' src; do
    if head -n1 "$src" | grep -q '^#!'; then
      local base dest
      base="$(basename "$src")"
      dest="${DEST_DIR}/${base}"
      if [[ -L "$dest" || -e "$dest" ]]; then
        local target
        target="$(readlink "$dest" 2>/dev/null || true)"
        if [[ "$target" == "$src" ]]; then
          ok "symlink exists: $dest"
        else
          run mv "$dest" "${dest}.bak.$(date +%s)"
          run ln -sf "$src" "$dest"
          ok "linked: $dest -> $src"
        fi
      else
        run ln -sf "$src" "$dest"
        ok "linked: $dest -> $src"
      fi
    fi
  done < <(find "${SCRIPTS_DIR}" -maxdepth 1 -type f ! -name 'doctor' ! -name 'bootstrap' -print0)
}

run_defaults() {
  if [[ "$(uname -s)" != "Darwin" ]]; then
    warn "defaults only supported on macOS (Darwin)"; return 0
  fi
  if [[ -f "${SCRIPTS_DIR}/defaults.sh" ]]; then
    run bash "${SCRIPTS_DIR}/defaults.sh"
  else
    warn "defaults.sh not found; skipping"
  fi
}

run_doctor() {
  if [[ -f "${SCRIPTS_DIR}/doctor" ]]; then
    run bash "${SCRIPTS_DIR}/doctor"
  else
    warn "no doctor script"
  fi
}

cmd="${1:-help}"
case "$cmd" in
  bootstrap) run_brew_bundle; link_dotfiles; link_tools; run_defaults; run_doctor ;;
  brew)      run_brew_bundle ;;
  dotfiles)  link_dotfiles ;;
  tools)     link_tools ;;
  defaults)  run_defaults ;;
  doctor)    run_doctor ;;
  help|-h|--help) usage ;;
  *) err "unknown command: $cmd"; usage; exit 1 ;;
esac

# --- Dry-run summary (if enabled) ---
if [[ "${DRY_RUN}" == "1" ]]; then
  # Colors (no emojis)
  BOLD="$(printf '\033[1m')"
  DIM="$(printf '\033[2m')"
  RESET="$(printf '\033[0m')"
  WHITE="$(printf '\033[37m')"
  BLUE="$(printf '\033[34m')"
  YELLOW="$(printf '\033[33m')"
  CYAN="$(printf '\033[36m')"
  MAGENTA="$(printf '\033[35m')"

  # Buckets
  declare -a DRY_BREW=() DRY_DEFAULTS=() DRY_DOTFILES=() DRY_TOOLS=() DRY_LINKS_MISC=() DRY_BACKUPS=() DRY_MKDIR=() DRY_OTHER=()

  # Categorize
  for cmdline in "${DRY_ACTIONS[@]}"; do
    if [[ "$cmdline" =~ ^brew[[:space:]]+bundle ]]; then
      DRY_BREW+=("$cmdline")
    elif [[ "$cmdline" =~ ^bash[[:space:]]+scripts/defaults\.sh ]] || [[ "$cmdline" =~ defaults[[:space:]]+write ]]; then
      DRY_DEFAULTS+=("$cmdline")
    elif [[ "$cmdline" =~ ^ln[[:space:]]+-s ]]; then
      if [[ "$cmdline" == *"${HOME}/."* ]]; then
        DRY_DOTFILES+=("$cmdline")
      elif [[ "$cmdline" == *"${HOME}/.local/bin/"* ]]; then
        DRY_TOOLS+=("$cmdline")
      else
        DRY_LINKS_MISC+=("$cmdline")
      fi
    elif [[ "$cmdline" =~ ^mv[[:space:]]+- ]]; then
      DRY_BACKUPS+=("$cmdline")
    elif [[ "$cmdline" =~ ^mkdir[[:space:]]+-p ]]; then
      DRY_MKDIR+=("$cmdline")
    else
      DRY_OTHER+=("$cmdline")
    fi
  done

  # Print sections
  print_section () {
    local title="$1" color="$2"; shift 2
    local -n arr=$1
    if ((${#arr[@]})); then
      printf "%s%s%s\n" "$BOLD$color" "$title" "$RESET"
      for item in "${arr[@]}"; do
        printf "  %s\n" "$item"
      done
      echo
    fi
  }

  echo
  printf "%sDRY-RUN SUMMARY (no changes)%s\n\n" "$BOLD$WHITE" "$RESET"
  print_section "BREW"          "$MAGENTA" DRY_BREW
  print_section "DEFAULTS"      "$WHITE"   DRY_DEFAULTS
  print_section "DOTFILES"      "$BLUE"    DRY_DOTFILES
  print_section "TOOLS"         "$CYAN"    DRY_TOOLS
  print_section "LINKS (MISC)"  "$CYAN"    DRY_LINKS_MISC
  print_section "BACKUPS/MOVES" "$YELLOW"  DRY_BACKUPS
  print_section "MKDIR"         "$CYAN"    DRY_MKDIR
  print_section "OTHER"         "$DIM"     DRY_OTHER

  if ((${#DRY_ACTIONS[@]}==0)); then
    printf "%s(no actions would be taken)%s\n" "$DIM" "$RESET"
  fi
fi
