#!/usr/bin/env bash
set -euo pipefail

# mrk1 installer â€” idempotent bootstrap for macOS (with Strap-inspired improvements)

ONLY=""
NO_BREW=0
NO_DOTFILES=0
NO_DEFAULTS=0
NO_LINK_TOOLS=0
DEBUG=0
CASKS_YES=0
CASKS_NO=0

while (("$#")); do
  case "$1" in
    --only) shift; ONLY="${1:-}" ;;
    --no-brew) NO_BREW=1 ;;
    --no-dotfiles) NO_DOTFILES=1 ;;
    --no-defaults) NO_DEFAULTS=1 ;;
    --no-link-tools) NO_LINK_TOOLS=1 ;;
    --yes-casks) CASKS_YES=1 ;;
    --no-casks) CASKS_NO=1 ;;
    --debug) DEBUG=1 ;;
    -h|--help)
      cat <<'USAGE'
mrk1 installer

Usage: scripts/install [options]
  --only <phase>     Run a single phase: brew|dotfiles|tools|defaults|shell
  --no-brew          Skip Homebrew install/bundle
  --no-dotfiles      Skip dotfiles linking
  --no-defaults      Skip macOS defaults
  --no-link-tools    Skip linking scripts/bin into ~/.local/bin
  --yes-casks        Install all casks without prompting
  --no-casks         Skip all casks without prompting
  --debug            Enable bash tracing (set -x)
Env:
  MRK1_DOTFILES_REPO   If set, clones repo to ~/.dotfiles and runs script/setup and script/strap-after-setup if present
  MRK1_LOGIN_MSG       If set, writes login window message (requires sudo), rollback added to ~/.mrk1/defaults-rollback.sh
USAGE
      exit 0
      ;;
    *) echo "Unknown option: $1" >&2; exit 2 ;;
  esac
  shift
done

(( DEBUG )) && set -x

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
ASSETS="$REPO_ROOT/assets"
BIN_DIR="$REPO_ROOT/bin"
SCRIPTS_DIR="$REPO_ROOT/scripts"
LOGFILE="$HOME/mrk1-install.log"
LOCAL_BIN="$HOME/.local/bin"
STATE_DIR="$HOME/.mrk1"
BACKUP_DIR="$STATE_DIR/backups/$(date +%Y%m%d-%H%M%S)"
ROLLBACK="$STATE_DIR/defaults-rollback.sh"

# Create required directories with error checking
if ! mkdir -p "$(dirname "$LOGFILE")" "$LOCAL_BIN" "$(dirname "$BACKUP_DIR")" "$STATE_DIR"; then
  err "Failed to create required directories"
  exit 1
fi

# Initialize rollback script
if ! : > "$ROLLBACK" || ! chmod +x "$ROLLBACK"; then
  err "Failed to initialize rollback script: $ROLLBACK"
  exit 1
fi

log()  { printf "[mrk1] %s\n" "$*"; }
warn() { printf "[warn] %s\n" "$*"; }
err()  { printf "[err ] %s\n" "$*"; }

exec > >(tee -a "$LOGFILE") 2>&1
log "Starting install... (log: $LOGFILE)"

BREWFILE="$ASSETS/Brewfile"
if [[ -f "$REPO_ROOT/Brewfile" ]]; then
  BREWFILE="$REPO_ROOT/Brewfile"
elif [[ -f "$HOME/.Brewfile" ]]; then
  BREWFILE="$HOME/.Brewfile"
fi

# Validate phase name
valid_phases="xcode brew tools dotfiles ext defaults shell"
validate_phase() {
  local phase="$1"
  case " $valid_phases " in
    *" $phase "*) return 0 ;;
    *) return 1 ;;
  esac
}

run_phase() {
  local name="$1"; shift
  if [[ -n "$ONLY" ]]; then
    if ! validate_phase "$ONLY"; then
      err "Invalid phase: $ONLY (valid: $valid_phases)"
      exit 2
    fi
    if [[ "$ONLY" != "$name" ]]; then return 0; fi
  fi
  "$@"
}

phase_xcode() {
  if ! xcode-select -p >/dev/null 2>&1; then
    log "Xcode Command Line Tools not found. Triggering install (GUI). Re-run after completion."
    xcode-select --install || true
  fi
  if [[ -d "/Applications/Xcode.app" ]]; then
    sudo xcodebuild -license accept >/dev/null 2>&1 || true
  fi
}

phase_brew() {
  if (( NO_BREW )); then log "Skipping brew (flag)"; return; fi
  if ! command -v brew >/dev/null 2>&1; then
    log "Installing Homebrew..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    echo 'eval "$($(brew --prefix)/bin/brew shellenv)"' >> "$HOME/.zprofile"
    eval "$($(brew --prefix)/bin/brew shellenv)"
  else
    log "Homebrew present."
  fi

  if [[ ! -f "$BREWFILE" ]]; then
    warn "No Brewfile found; skipping bundle"
    return 0
  fi

  # Use interactive bundle script if available, otherwise fall back to plain brew bundle
  local bundle_script="$SCRIPTS_DIR/bundle-interactive"
  if [[ -x "$bundle_script" ]]; then
    # Check if we should use interactive mode
    if (( CASKS_YES )); then
      log "Running brew bundle (installing all casks)..."
    elif (( CASKS_NO )); then
      log "Running brew bundle (skipping all casks)..."
    else
      log "Running interactive brew bundle (casks will be prompted)..."
    fi
    
    local bundle_args=("$BREWFILE")
    
    # Pass flags to bundle-interactive
    if (( CASKS_YES )); then
      bundle_args+=(--yes)
    elif (( CASKS_NO )); then
      bundle_args+=(--no)
    fi
    
    # Run bundle-interactive with stdin explicitly connected to terminal
    # This ensures interactive prompts work even when output is redirected
    # Only redirect stdin if we're in interactive mode (not --yes-casks or --no-casks)
    if (( CASKS_YES )) || (( CASKS_NO )); then
      # Non-interactive mode - don't redirect stdin
      if "$bundle_script" "${bundle_args[@]}"; then
        log "Brew bundle completed"
      else
        local exit_code=$?
        if (( exit_code == 1 )); then
          warn "Brew bundle had some failures (check output above)"
        else
          warn "Brew bundle returned non-zero: $exit_code"
        fi
      fi
    else
      # Interactive mode - ensure stdin comes from terminal
      if [[ -t 0 ]] && [[ -c /dev/tty ]]; then
        if "$bundle_script" "${bundle_args[@]}" < /dev/tty; then
          log "Brew bundle completed"
        else
          local exit_code=$?
          if (( exit_code == 1 )); then
            warn "Brew bundle had some failures (check output above)"
          else
            warn "Brew bundle returned non-zero: $exit_code"
          fi
        fi
      else
        # Fallback if /dev/tty is not available
        if "$bundle_script" "${bundle_args[@]}"; then
          log "Brew bundle completed"
        else
          warn "Brew bundle returned non-zero"
        fi
      fi
    fi
  else
    log "Running brew bundle using $BREWFILE (non-interactive)..."
    log "Note: Install scripts/bundle-interactive for interactive cask installation"
    brew bundle --file="$BREWFILE" || warn "brew bundle returned non-zero"
  fi
}

phase_link_tools() {
  if (( NO_LINK_TOOLS )); then log "Skipping link-tools (flag)"; return; fi
  
  if [[ ! -d "$LOCAL_BIN" ]]; then
    if ! mkdir -p "$LOCAL_BIN"; then
      err "Failed to create $LOCAL_BIN directory"
      return 1
    fi
  fi
  
  log "Linking scripts/* and bin/* into $LOCAL_BIN..."
  local linked=0
  local failed=0
  
  if [[ -d "$SCRIPTS_DIR" ]]; then
    while IFS= read -r -d '' f; do
      [[ -f "$f" && -x "$f" ]] || continue
      local base
      base="$(basename "$f")"
      if ln -sf "$f" "$LOCAL_BIN/$base"; then
        ((linked++))
      else
        err "Failed to link: $LOCAL_BIN/$base"
        ((failed++))
      fi
    done < <(find "$SCRIPTS_DIR" -maxdepth 1 -type f -print0 2>/dev/null || true)
  fi
  
  if [[ -d "$BIN_DIR" ]]; then
    while IFS= read -r -d '' f; do
      [[ -f "$f" && -x "$f" ]] || continue
      local base
      base="$(basename "$f")"
      if ln -sf "$f" "$LOCAL_BIN/$base"; then
        ((linked++))
      else
        err "Failed to link: $LOCAL_BIN/$base"
        ((failed++))
      fi
    done < <(find "$BIN_DIR" -maxdepth 1 -type f -print0 2>/dev/null || true)
  fi
  
  if (( linked > 0 )); then
    log "Linked $linked tool(s) into $LOCAL_BIN"
  fi
  
  if (( failed > 0 )); then
    warn "$failed symlink(s) failed to create"
    return 1
  fi
}

phase_dotfiles() {
  if (( NO_DOTFILES )); then log "Skipping dotfiles (flag)"; return; fi
  
  if [[ ! -d "$REPO_ROOT/dotfiles" ]]; then
    warn "dotfiles directory not found: $REPO_ROOT/dotfiles"
    return 0
  fi
  
  local src dst
  if ! mkdir -p "$BACKUP_DIR"; then
    err "Failed to create backup directory: $BACKUP_DIR"
    return 1
  fi
  
  shopt -s dotglob nullglob
  local found=0
  for src in "$REPO_ROOT/dotfiles"/*; do
    [[ -e "$src" ]] || continue
    found=1
    dst="$HOME/$(basename "$src")"
    if [[ -e "$dst" && ! -L "$dst" ]]; then
      log "Backing up: $dst -> $BACKUP_DIR/$(basename "$dst")"
      if ! mv "$dst" "$BACKUP_DIR/"; then
        err "Failed to backup $dst - aborting dotfile linking"
        shopt -u dotglob nullglob
        return 1
      fi
    fi
    if ! ln -sfn "$src" "$dst"; then
      err "Failed to create symlink: $dst -> $src"
      shopt -u dotglob nullglob
      return 1
    fi
  done
  shopt -u dotglob nullglob
  
  if (( !found )); then
    warn "No dotfiles found in $REPO_ROOT/dotfiles"
  fi
}

# Validate git URL format (basic check)
is_valid_git_url() {
  local url="$1"
  # Allow http://, https://, git@, or file:// URLs
  if [[ "$url" =~ ^(https?://|git@|file://|ssh://).+\.git$ ]] || \
     [[ "$url" =~ ^(https?://|git@|file://|ssh://)[^[:space:]]+$ ]]; then
    return 0
  fi
  return 1
}

phase_ext_dotfiles() {
  if [[ -z "${MRK1_DOTFILES_REPO:-}" ]]; then
    return 0
  fi
  
  local DOTDIR="$HOME/.dotfiles"
  
  # Validate URL format
  if ! is_valid_git_url "$MRK1_DOTFILES_REPO"; then
    err "Invalid git URL format: $MRK1_DOTFILES_REPO"
    warn "URL should be in format: https://github.com/user/repo.git or git@github.com:user/repo.git"
    return 1
  fi
  
  if [[ ! -d "$DOTDIR/.git" ]]; then
    log "Cloning external dotfiles repo: $MRK1_DOTFILES_REPO"
    if ! git clone --depth 1 "$MRK1_DOTFILES_REPO" "$DOTDIR"; then
      err "Failed to clone dotfiles repo"
      return 1
    fi
  else
    log "External dotfiles repo present at $DOTDIR"
  fi
  
  # Execute external scripts with explicit confirmation
  if [[ -x "$DOTDIR/script/setup" ]]; then
    log "Running external setup script: $DOTDIR/script/setup"
    if ! "$DOTDIR/script/setup"; then
      warn "External setup script returned non-zero"
    fi
  fi
  
  if [[ -x "$DOTDIR/script/strap-after-setup" ]]; then
    log "Running external strap-after-setup script: $DOTDIR/script/strap-after-setup"
    if ! "$DOTDIR/script/strap-after-setup"; then
      warn "External strap-after-setup script returned non-zero"
    fi
  fi
}

phase_defaults() {
  if (( NO_DEFAULTS )); then log "Skipping defaults (flag)"; return; fi
  if [[ -x "$SCRIPTS_DIR/defaults.sh" ]]; then
    "$SCRIPTS_DIR/defaults.sh"
  else
    warn "defaults.sh not found/executable; skipping"
  fi

  if [[ -n "${MRK1_LOGIN_MSG:-}" ]]; then
    if command -v sudo >/dev/null 2>&1; then
      log "Setting login window message"
      # Note: defaults write handles string escaping, but we validate the message isn't empty
      if [[ -z "$MRK1_LOGIN_MSG" ]]; then
        warn "MRK1_LOGIN_MSG is empty, skipping"
        return 0
      fi
      if sudo defaults write /Library/Preferences/com.apple.loginwindow LoginwindowText "$MRK1_LOGIN_MSG"; then
        echo "sudo defaults delete /Library/Preferences/com.apple.loginwindow LoginwindowText" >> "$ROLLBACK"
      else
        err "Failed to set login window message"
        return 1
      fi
    else
      warn "sudo not available; cannot set login window message"
    fi
  fi
}

phase_shell() {
  if command -v zsh >/dev/null 2>&1; then
    local target_shell
    target_shell="$(command -v zsh)"
    if [[ "$(dscl . -read "/Users/$USER" UserShell 2>/dev/null | awk '{print $2}')" != "$target_shell" ]]; then
      log "Setting login shell to $target_shell"
      chsh -s "$target_shell" || warn "chsh failed"
    else
      log "Login shell already $target_shell"
    fi
  fi
}

run_phase xcode    phase_xcode
run_phase brew     phase_brew
run_phase tools    phase_link_tools
run_phase dotfiles phase_dotfiles
run_phase ext      phase_ext_dotfiles
run_phase defaults phase_defaults
run_phase shell    phase_shell

log "Install complete."
