\
#!/usr/bin/env bash
set -euo pipefail

# Config (env-overridable)
: "${SYNCALL_ROOT:="$HOME"}"
: "${SYNCALL_MAX_DEPTH:=7}"   # search depth under $HOME (if supported by find)
: "${SYNCALL_ONLY_GITHUB:=1}" # 1 = only repos whose remotes include github.com
: "${SYNCALL_DRY_RUN:=0}"     # 1 = preview only (or pass --dry-run)
: "${SYNCALL_EXCLUDES:="$HOME/Library:$HOME/.Trash:$HOME/.venvs:$HOME/.cache:$HOME/.cargo:$HOME/.npm:_build:node_modules:.git/modules"}"
: "${SYNCALL_DEFAULT_REMOTE:=origin}" # fallback remote if no upstream is set

# Optional: set to your GH username to only include repos you "own"
# export SYNCALL_GH_OWNER="sevmorris"

# Colors
if command -v tput >/dev/null 2>&1 && [[ -t 1 ]]; then
  bold=$(tput bold)
  green=$(tput setaf 2)
  cyan=$(tput setaf 6)
  yellow=$(tput setaf 3)
  red=$(tput setaf 1)
  reset=$(tput sgr0)
else
  bold=""; green=""; cyan=""; yellow=""; red=""; reset=""
fi
log() { printf "%s%s%s\n" "$cyan" "$*" "$reset"; }
good() { printf "%s%s%s\n" "$green" "$*" "$reset"; }
warn() { printf "%s%s%s\n" "$yellow" "$*" "$reset"; }
err() { printf "%s%s%s\n" "$red" "$*" "$reset" >&2; }

# Git helpers
git_toplevel() { git -C "$1" rev-parse --show-toplevel 2>/dev/null; }
has_remote_github() { git -C "$1" remote -v | grep -q 'github\.com'; }
current_branch() { git -C "$1" rev-parse --abbrev-ref HEAD 2>/dev/null; }
can_push() {
  local dir="$1" remote="${2:-$SYNCALL_DEFAULT_REMOTE}" branch
  branch="$(current_branch "$dir")" || return 1
  GIT_TERMINAL_PROMPT=0 git -C "$dir" push --dry-run -q "$remote" "HEAD:$branch" &>/dev/null
}

push_repo() {
  local dir="$1" remote="${2:-$SYNCALL_DEFAULT_REMOTE}" branch
  branch="$(current_branch "$dir")" || return 1
  if [[ "${SYNCALL_DRY_RUN}" == "1" ]]; then
    log "DRY-RUN: would push $dir ($remote → $branch)"
  else
    git -C "$dir" push "$remote" "HEAD:$branch" && good "pushed: $dir"
  fi
}

build_prune_expr() {
  local IFS=':'
  read -r -a paths <<<"$SYNCALL_EXCLUDES"
  PRUNE_EXPR=()
  for p in "${paths[@]}"; do
    [[ -z "$p" ]] && continue
    PRUNE_EXPR+=(-path "$p" -o)
  done
  if ((${#PRUNE_EXPR[@]} >= 1)) && [[ "${PRUNE_EXPR[-1]}" == "-o" ]]; then
    unset 'PRUNE_EXPR[-1]'
  fi
}

discover_repos() {
  build_prune_expr
  local have_maxdepth=0
  if find . -maxdepth 0 -print >/dev/null 2>&1; then have_maxdepth=1; fi

  local -a cmd=(find "$SYNCALL_ROOT" -xdev)
  if [[ $have_maxdepth -eq 1 ]]; then cmd+=(-maxdepth "$SYNCALL_MAX_DEPTH"); fi
  if ((${#PRUNE_EXPR[@]})); then cmd+=(\( "${PRUNE_EXPR[@]}" \) -prune -o); fi
  cmd+=(\( -type d -name .git -o -type f -name .git \) -print)

  "${cmd[@]}" 2>/dev/null \
    | while IFS= read -r git_marker; do
      repo_dir="$(dirname "$git_marker")"
      toplevel="$(git_toplevel "$repo_dir" || true)"
      [[ -n "$toplevel" ]] && printf '%s\n' "$toplevel"
    done | sort -u
}

main() {
  log "${bold}Syncing repos under ${SYNCALL_ROOT}${reset}"
  repos=()
  while IFS= read -r r; do repos+=("$r"); done < <(discover_repos)

  for r in "${repos[@]}"; do
    [[ -d "$r/.git" ]] || continue
    if [[ "$SYNCALL_ONLY_GITHUB" == "1" ]] && ! has_remote_github "$r"; then
      warn "skip (non-GitHub): $r"
      continue
    fi
    if can_push "$r"; then
      push_repo "$r"
    else
      warn "no push permission: $r"
    fi
  done

  echo
  good "––––––––––––––"
  log "${bold}Sync complete${reset}"
  mkdir -p "${HOME}/.cache/mrk1"
  echo "syncall ran on $(date)" >>"${HOME}/.cache/mrk1/syncall.log"
  good "––––––––––––––"
}

main "$@"
